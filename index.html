<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Memoroa</title>
  <link rel="manifest" href="./manifest.json">
  <style>
    /* 你的原本 CSS 完整保留（不變） */
    :root {
      --bg-color: #f5f7fa;
      --sidebar-bg: #ffffff;
      --note-item-hover: #eef1f5;
      --note-item-active: #e0e9f0;
      --primary-color: #007bff;
      --btn-text-color: #ffffff;
      --border-color: #e0e6ed;
      --text-color: #333;
      --placeholder-color: #93a5b8;
      --shadow-light: 0 4px 6px rgba(0, 0, 0, 0.05);
      --delete-btn-color: #999;
    }

    body {
      font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
      display: flex;
      height: 100vh;
      margin: 0;
      background-color: var(--bg-color);
      color: var(--text-color);
      overflow: hidden;
    }

    #sidebar {
      width: 300px;
      background-color: var(--sidebar-bg);
      padding: 20px 0;
      border-right: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      box-shadow: var(--shadow-light);
      transition: width 0.3s ease;
    }

    #new-note-btn {
      type: button;
      background-color: var(--primary-color);
      color: var(--btn-text-color);
      border: none;
      padding: 12px 20px;
      margin: 0 20px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      transition: background-color 0.2s ease, transform 0.1s ease;
    }

    #new-note-btn:hover {
      background-color: #0056b3;
      transform: translateY(-1px);
    }

    #note-list {
      list-style: none;
      padding: 0;
      margin: 0;
      flex-grow: 1;
      overflow-y: auto;
    }

    .note-item {
      padding: 15px 20px;
      cursor: pointer;
      border-bottom: 1px solid var(--border-color);
      transition: background-color 0.2s ease;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .note-item:hover {
      background-color: var(--note-item-hover);
    }

    .note-item.active {
      background-color: var(--note-item-active);
      border-left: 4px solid var(--primary-color);
      padding-left: 16px;
    }

    .note-title {
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex-grow: 1;
    }

    .note-preview {
      font-size: 14px;
      color: var(--placeholder-color);
      margin-top: 5px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .delete-btn {
      background: none;
      border: none;
      color: var(--delete-btn-color);
      font-size: 18px;
      cursor: pointer;
      opacity: 0.5;
      transition: opacity 0.2s ease, color 0.2s ease;
      margin-left: 10px;
    }

    .delete-btn:hover {
      color: red;
      opacity: 1;
    }

    #main-content {
      flex-grow: 1;
      padding: 30px;
      display: flex;
      flex-direction: column;
      min-height: 0; /* 允許內層滾動 */
    }

    #toolbar {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
      background-color: var(--sidebar-bg);
      padding: 10px;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      align-items: center;
    }

    .format-btn {
      background-color: var(--note-item-hover);
      border: 1px solid var(--border-color);
      padding: 8px 12px;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
      font-size: 16px;
    }

    .backup-btn {
      margin-left: auto;
      background-color: #2d9cdb;
      color: #fff;
      border: none;
      padding: 8px 10px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
    }

    .backup-btn:hover { filter: brightness(0.95); }

    #note-editor {
      width: 100%;
      flex-grow: 1;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 20px;
      font-size: 18px;
      line-height: 1.6;
      background-color: var(--sidebar-bg);
      box-shadow: var(--shadow-light);
      transition: all 0.2s ease;
      outline: none;
      overflow-y: auto;
      white-space: pre-wrap;
      word-wrap: break-word;
      min-height: 0;
    }

    #note-editor:focus {
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
    }

    #note-editor[contenteditable="true"]:empty::before {
      content: attr(data-placeholder);
      color: var(--placeholder-color);
    }

    #note-editor ul li { list-style-type: none; }
    #note-editor ul li::before {
      content: '➣';
      color: var(--primary-color);
      display: inline-block;
      width: 1em;
      margin-left: -1em;
    }

    @media (max-width: 768px) {
      body { flex-direction: column; }
      #sidebar { width: 100%; height: 35vh; border-right: none; border-bottom: 1px solid var(--border-color); padding: 10px 0; }
      #new-note-btn { margin: 0 15px 15px; padding: 10px 15px; }
      #note-list { flex-grow: 1; overflow-y: auto; padding-bottom: 10px; }
      .note-item { padding: 12px 15px; }
      #main-content { flex-grow: 1; padding: 15px; }
      #note-editor { width: calc(100% - 2px); box-sizing: border-box; min-height: 150px; height: auto; }
    }
  </style>
</head>
<body>
  <div id="sidebar">
    <button id="new-note-btn" type="button">＋ 新增筆記</button>
    <ul id="note-list"></ul>
  </div>

  <div id="main-content">
    <div id="toolbar">
      <button class="format-btn" type="button" onclick="formatDoc('bold')"><b>粗體</b></button>
      <button class="format-btn" type="button" onclick="formatDoc('italic')"><i>斜體</i></button>
      <button class="format-btn" type="button" onclick="formatDoc('insertUnorderedList')">項目</button>
      <button class="format-btn" type="button" onclick="formatDoc('insertOrderedList')">數字</button>

      <!-- 備份 / 還原按鈕 -->
      <button id="backupBtn" class="backup-btn" type="button">備份到裝置</button>
      <button id="restoreBtn" class="backup-btn" type="button" style="background-color:#4caf50;margin-left:6px">從裝置還原</button>
    </div>

    <div id="note-editor" contenteditable="true" data-placeholder="在此開始寫筆記..."></div>
  </div>
<script>
  const noteListEl = document.getElementById('noteList');
const editor = document.getElementById('note-editor');
const btnNew = document.getElementById('btnNew');

let notes = [];
let currentId = null;
let saveTimer = null;

function getNotesFromStorage(){
  try{ return JSON.parse(localStorage.getItem('notes')||'[]'); }
  catch(e){ return []; }
}

function persistNotes(){ localStorage.setItem('notes', JSON.stringify(notes)); }

function renderSidebar(){
  noteListEl.innerHTML = '';
  notes.forEach(n=>{
    const el = document.createElement('div');
    el.style.padding='8px';
    el.style.borderBottom='1px solid #f0f0f0';
    el.style.cursor='pointer';
    el.textContent = ( (n.content||'').replace(/<[^>]+>/g,'') ).split('\n')[0] || '新筆記';
    el.addEventListener('click', ()=>selectNote(n.id));
    noteListEl.appendChild(el);
  });
}

function selectNote(id){
  const n = notes.find(x=>x.id===id);
  if(!n) return;
  currentId = id;
  editor.innerHTML = n.content;
  editor.focus();
}

function newNote(){
  const n = { id: Date.now().toString(), content: '' };
  notes.unshift(n);
  persistNotes();
  renderSidebar();
  selectNote(n.id);
}
btnNew.addEventListener('click', newNote);

function saveNoteIfNeeded(){
  clearTimeout(saveTimer);
  saveTimer = setTimeout(()=>{
    const html = editor.innerHTML;
    if(currentId){
      const idx = notes.findIndex(n=>n.id===currentId);
      if(idx>=0){
        notes[idx].content = html;
      }
    } else {
      if(html.trim()){
        const n = { id: Date.now().toString(), content: html };
        notes.unshift(n);
        currentId = n.id;
      }
    }
    persistNotes();
    renderSidebar();
  }, 400);
}
editor.addEventListener('input', saveNoteIfNeeded);

/* load on start */
notes = getNotesFromStorage();
if(notes.length===0) newNote();
else { renderSidebar(); selectNote(notes[0].id); }

/* format buttons */
document.querySelectorAll('.format-btn').forEach(btn=>{
  btn.addEventListener('click', ()=> {
    const cmd = btn.getAttribute('data-cmd');
    document.execCommand(cmd, false, null);
    editor.focus();
  });
});

/* ================= backup/restore 加密邏輯（AES-GCM 也可，但用簡單 PBKDF+AES 會較複雜）
   我這裡用 WebCrypto 的 PBKDF2 + AES-GCM 的正規流程（和你提供邏輯一致）
   但最重要：**收密碼的 UI 改成 modal** -> 可保持 user gesture on mobile。
   ===================================================================== */

const pwModal = document.getElementById('pwModal');
const pwInput = document.getElementById('pwInput');
const pwOk = document.getElementById('pwOk');
const pwCancel = document.getElementById('pwCancel');
const pwTitle = document.getElementById('pwTitle');

const FILE_MAGIC = 'MEMO';
const SALT_LEN = 16;
const IV_LEN = 12;
const PBKDF2_ITER = 150000;

function getRandomBytes(len){ const b=new Uint8Array(len); crypto.getRandomValues(b); return b; }
async function deriveKeyFromPassword(password, salt){
  const enc = new TextEncoder();
  const baseKey = await crypto.subtle.importKey('raw', enc.encode(password), 'PBKDF2', false, ['deriveKey']);
  const key = await crypto.subtle.deriveKey(
    { name:'PBKDF2', salt: salt, iterations: PBKDF2_ITER, hash:'SHA-256' },
    baseKey,
    { name:'AES-GCM', length:256 },
    false,
    ['encrypt','decrypt']
  );
  return key;
}

async function encryptNotes(notesArray, password){
  const salt = getRandomBytes(SALT_LEN);
  const iv = getRandomBytes(IV_LEN);
  const key = await deriveKeyFromPassword(password, salt);
  const enc = new TextEncoder();
  const plaintext = enc.encode(JSON.stringify(notesArray));
  const cipher = await crypto.subtle.encrypt({ name:'AES-GCM', iv: iv }, key, plaintext);
  const magic = new TextEncoder().encode(FILE_MAGIC);
  const out = new Uint8Array(magic.length + salt.length + iv.length + cipher.byteLength);
  let off=0;
  out.set(magic, off); off+=magic.length;
  out.set(salt, off); off+=salt.length;
  out.set(iv, off); off+=iv.length;
  out.set(new Uint8Array(cipher), off);
  return out.buffer;
}

async function decryptNotes(arrayBuffer, password){
  const data = new Uint8Array(arrayBuffer);
  const magicLen = FILE_MAGIC.length;
  const magic = new TextDecoder().decode(data.slice(0, magicLen));
  if(magic !== FILE_MAGIC) throw new Error('檔案格式錯誤');
  const salt = data.slice(magicLen, magicLen+SALT_LEN).buffer;
  const iv = data.slice(magicLen+SALT_LEN, magicLen+SALT_LEN+IV_LEN);
  const cipher = data.slice(magicLen+SALT_LEN+IV_LEN).buffer;
  const key = await deriveKeyFromPassword(password, salt);
  const plain = await crypto.subtle.decrypt({ name:'AES-GCM', iv: iv }, key, cipher);
  return JSON.parse(new TextDecoder().decode(plain));
}

/* save file helper with fallback (download link) */
async function saveArrayBufferToDevice(buf, suggestedName='memoroa.dat'){
  // if showSaveFilePicker available, use it (must be directly called after user event)
  if(window.showSaveFilePicker){
    const opts = { suggestedName, types:[{ description:'Memoroa backup', accept:{ 'application/octet-stream':['.dat'] }}] };
    const handle = await window.showSaveFilePicker(opts);
    const writable = await handle.createWritable();
    await writable.write(buf);
    await writable.close();
    return true;
  } else {
    // fallback: trigger download
    const blob = new Blob([buf], { type:'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = suggestedName;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    return true;
  }
}

/* open file helper with fallback (input) */
async function openFileFromDevice(){
  if(window.showOpenFilePicker){
    const [handle] = await window.showOpenFilePicker({ types:[{ description:'Memoroa backup', accept:{ 'application/octet-stream':['.dat'] }}], multiple:false });
    const file = await handle.getFile();
    const ab = await file.arrayBuffer();
    return ab;
  } else {
    return await new Promise((resolve,reject)=>{
      const input = document.createElement('input');
      input.type='file';
      input.accept='.dat,application/octet-stream';
      input.onchange = async (e)=>{
        const f = e.target.files[0];
        if(!f) { reject(new Error('使用者取消')); return; }
        const ab = await f.arrayBuffer();
        resolve(ab);
      };
      input.click();
    });
  }
}

/* ---------- Modal 控制器：顯示 modal 並等候使用者輸入密碼（非 window.prompt） ----------
   這樣在 mobile/desktop 都能維持「user gesture」，避免 showSaveFilePicker 被視為非使用者觸發。
   用法： await askPassword('備份：請輸入密碼') -> 回傳輸入字串或 throw('cancel')
*/
function askPassword(title){
  return new Promise((resolve,reject)=>{
    pwTitle.textContent = title || '請輸入密碼';
    pwInput.value = '';
    pwModal.style.display = 'flex';
    pwInput.focus();

    function cleanup(){
      pwModal.style.display = 'none';
      pwOk.removeEventListener('click', onOk);
      pwCancel.removeEventListener('click', onCancel);
      pwInput.removeEventListener('keydown', onKey);
    }
    function onOk(){
      const v = pwInput.value;
      if(!v){ alert('密碼不可為空'); return; }
      cleanup();
      resolve(v);
    }
    function onCancel(){
      cleanup();
      reject(new Error('使用者取消'));
    }
    function onKey(e){
      if(e.key==='Enter'){ onOk(); }
      if(e.key==='Escape'){ onCancel(); }
    }
    pwOk.addEventListener('click', onOk);
    pwCancel.addEventListener('click', onCancel);
    pwInput.addEventListener('keydown', onKey);
  });
}

/* ---------- 備份流程（按鈕事件） ---------- */
document.getElementById('backupBtn').addEventListener('click', async (e)=>{
  try{
    // 1) 先取得 notes（同步）
    const currentNotes = getNotesFromStorage();

    if(!currentNotes || currentNotes.length===0){
      alert('目前沒有筆記可備份。');
      return;
    }

    // 2) 透過內嵌 modal 取得密碼（確保在同一個使用者操作流程）
    const password = await askPassword('備份：請輸入備份密碼（請記住）');

    // 3) 加密並儲存
    const buf = await encryptNotes(currentNotes, password);
    await saveArrayBufferToDevice(buf, 'memoroa.dat');

    alert('備份成功（已下載或寫入裝置）。');
  }catch(err){
    if(err && err.message==='使用者取消') return;
    console.error(err);
    alert('備份失敗：' + (err && err.message ? err.message : err));
  }
});

/* ---------- 還原流程 ---------- */
document.getElementById('restoreBtn').addEventListener('click', async ()=>{
  try{
    const buf = await openFileFromDevice();
    // 取得密碼
    const password = await askPassword('還原：請輸入備份檔案的密碼');
    const notesArr = await decryptNotes(buf, password);
    // 覆蓋 localStorage（按你之前的要求）
    localStorage.setItem('notes', JSON.stringify(notesArr));
    notes = notesArr;
    renderSidebar();
    if(notes.length>0) selectNote(notes[0].id);
    alert('還原成功（已覆蓋本地筆記）。');
  }catch(err){
    if(err && err.message==='使用者取消') return;
    console.error(err);
    alert('還原失敗：' + (err && err.message ? err.message : err));
  }
});

/* optional: close modal on outside click (保守處理) */
pwModal.addEventListener('click', (e)=>{
  if(e.target===pwModal){
    // do nothing or close? 我選擇不自動關閉，避免誤觸
  }
});
</script>
</body>
</html>
