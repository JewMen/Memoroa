<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Memoroa</title>
  <link rel="manifest" href="./manifest.json">
  <style>
    /* --- 還原的主要版面樣式（貼近你提供的截圖） --- */
    :root{
      --sidebar-w: 260px;
      --primary-blue: #0b8cff;
      --btn-blue: #2ea0ff;
      --btn-green: #4caf50;
      --tool-bg: #f5f7fa;
      --card-border: #d7e7ff;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family: "Microsoft JhengHei", Arial, sans-serif;}
    .app{
      display:flex;
      height:100vh;
      background:#ffffff;
    }

    /* 左側側欄 */
    .sidebar{
      width:var(--sidebar-w);
      border-right:1px solid #eee;
      padding:18px 14px;
      display:flex;
      flex-direction:column;
      gap:12px;
      align-items:flex-start;
    }
    .btn-new{
      width:100%;
      background:var(--primary-blue);
      color:#fff;
      border-radius:8px;
      padding:10px 12px;
      font-weight:600;
      border:none;
      cursor:pointer;
      box-shadow: 0 2px 0 rgba(0,0,0,0.06);
    }
    .note-list{
      margin-top:6px;
      width:100%;
      flex:1;
      overflow:auto;
    }

    /* 右方主區 */
    .main{
      flex:1;
      padding:18px;
    }
    .toolbar{
      display:flex;
      align-items:center;
      gap:8px;
      padding:10px;
      background: #fafafa;
      border-radius:8px;
      border:1px solid #eee;
    }

    /* 格式按鈕（小灰） */
    .format-btn{
      background:#fff;
      border:1px solid #ddd;
      padding:6px 10px;
      border-radius:6px;
      cursor:pointer;
      font-weight:700;
      color:#333;
      box-shadow:none;
    }

    /* 右上備份/還原按鈕（縮小樣式） */
    .right-actions{ margin-left:auto; display:flex; gap:8px; }
    .backup-btn{
      background:var(--btn-blue);
      color:white;
      border:none;
      padding:8px 12px;
      border-radius:6px;
      cursor:pointer;
    }
    .restore-btn{
      background:var(--btn-green);
      color:white;
      border:none;
      padding:8px 12px;
      border-radius:6px;
      cursor:pointer;
    }

    /* 編輯器區 */
    .editor-wrap{
      margin-top:12px;
      border:1px solid var(--card-border);
      border-radius:6px;
      padding:12px;
      height: calc(100vh - 140px);
      overflow:auto;
      background:#fff;
    }
    #note-editor{
      width:100%;
      height:100%;
      outline:none;
      border:0;
      resize:none;
      font-size:16px;
      line-height:1.8;
      color:#222;
      white-space:pre-wrap;
    }
    #note-editor:focus{ box-shadow: 0 0 0 3px rgba(11,140,255,0.12); }

    /* 密碼小視窗（輕量 modal）*/
    .pw-modal{
      position:fixed;
      left:0;right:0;top:0;bottom:0;
      display:none;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,0.28);
      z-index:9999;
    }
    .pw-card{
      background:white;
      padding:18px;
      border-radius:8px;
      min-width:300px;
      box-shadow:0 8px 24px rgba(0,0,0,0.12);
    }
    .pw-card h3{ margin:0 0 8px 0; font-size:16px; }
    .pw-card input{
      width:100%;
      padding:8px 10px;
      margin-bottom:10px;
      border:1px solid #ddd;
      border-radius:6px;
      font-size:15px;
    }
    .pw-actions{ display:flex; gap:8px; justify-content:flex-end; }
    .pw-actions button{ padding:8px 12px; border-radius:6px; cursor:pointer; border:none; }
    .pw-ok{ background:var(--btn-blue); color:white;}
    .pw-cancel{ background:#f0f0f0; color:#333; }

    /* small responsive */
    @media (max-width:800px){
      .sidebar{ display:none; }
      .editor-wrap{ height: calc(100vh - 120px); }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="sidebar">
      <button class="btn-new" id="btnNew" type="button">＋ 新增筆記</button>
      <div class="note-list" id="noteList"></div>
    </div>

    <div class="main">
      <div class="toolbar">
        <button class="format-btn" data-cmd="bold" type="button"><b>粗體</b></button>
        <button class="format-btn" data-cmd="italic" type="button"><i>斜體</i></button>
        <button class="format-btn" data-cmd="insertUnorderedList" type="button">項目</button>
        <button class="format-btn" data-cmd="insertOrderedList" type="button">數字</button>

        <div class="right-actions">
          <button class="backup-btn" id="backupBtn" type="button">備份到裝置</button>
          <button class="restore-btn" id="restoreBtn" type="button">從裝置還原</button>
        </div>
      </div>

      <div class="editor-wrap">
        <div id="note-editor" contenteditable="true" data-placeholder="在此開始寫筆記..."></div>
      </div>
    </div>
  </div>

  <!-- 密碼 modal -->
  <div class="pw-modal" id="pwModal" aria-hidden="true">
    <div class="pw-card">
      <h3 id="pwTitle">請輸入備份密碼</h3>
      <input id="pwInput" type="password" placeholder="輸入密碼，至少 4 字元" />
      <div class="pw-actions">
        <button class="pw-cancel" id="pwCancel" type="button">取消</button>
        <button class="pw-ok" id="pwOk" type="button">確定</button>
      </div>
    </div>
  </div>

<script>
/* ========= 筆記 App 基本行為（保留原本邏輯，修正 bug） ========= */
const noteListEl = document.getElementById('noteList');
const editor = document.getElementById('note-editor');
const btnNew = document.getElementById('btnNew');

let notes = [];
let currentId = null;
let saveTimer = null;

function getNotesFromStorage(){
  try{ return JSON.parse(localStorage.getItem('notes')||'[]'); }
  catch(e){ return []; }
}
function persistNotes(){ localStorage.setItem('notes', JSON.stringify(notes)); }

function renderSidebar(){
  noteListEl.innerHTML = '';
  notes.forEach(n=>{
    const el = document.createElement('div');
    el.style.padding='8px';
    el.style.borderBottom='1px solid #f0f0f0';
    el.style.cursor='pointer';
    el.textContent = ( (n.content||'').replace(/<[^>]+>/g,'') ).split('\n')[0] || '新筆記';
    // 使用 mousedown 減少 contentEditable focus 衝突
    el.addEventListener('mousedown', ()=>selectNote(n.id));
    noteListEl.appendChild(el);
  });
}

function selectNote(id){
  const n = notes.find(x=>x.id===id);
  if(!n) return;
  currentId = id;
  editor.innerHTML = n.content;
  editor.focus();
}

function newNote(){
  const n = { id: Date.now().toString(), content: '' };
  notes.unshift(n);
  persistNotes();
  renderSidebar();
  selectNote(n.id);
}
btnNew.addEventListener('click', newNote);

function saveNoteIfNeeded(){
  clearTimeout(saveTimer);
  saveTimer = setTimeout(()=>{
    const html = editor.innerHTML;
    if(currentId){
      const idx = notes.findIndex(n=>n.id===currentId);
      if(idx>=0){
        notes[idx].content = html;
      }
    } else {
      if(html.trim()){
        const n = { id: Date.now().toString(), content: html };
        notes.unshift(n);
        currentId = n.id;
      }
    }
    persistNotes();
    renderSidebar();
  }, 400);
}
editor.addEventListener('input', saveNoteIfNeeded);

notes = getNotesFromStorage();
if(notes.length===0) newNote();
else { renderSidebar(); selectNote(notes[0].id); }

document.querySelectorAll('.format-btn').forEach(btn=>{
  btn.addEventListener('click', ()=> {
    const cmd = btn.getAttribute('data-cmd');
    document.execCommand(cmd, false, null);
    editor.focus();
  });
});

/* ========== 加密備份/還原邏輯（WebCrypto AES-GCM + PBKDF2） ========== */
const pwModal = document.getElementById('pwModal');
const pwInput = document.getElementById('pwInput');
const pwOk = document.getElementById('pwOk');
const pwCancel = document.getElementById('pwCancel');
const pwTitle = document.getElementById('pwTitle');

const FILE_MAGIC = 'MEMO';
const SALT_LEN = 16;
const IV_LEN = 12;
const PBKDF2_ITER = 150000;

function getRandomBytes(len){ const b=new Uint8Array(len); crypto.getRandomValues(b); return b; }
async function deriveKeyFromPassword(password, salt){
  const enc = new TextEncoder();
  const baseKey = await crypto.subtle.importKey('raw', enc.encode(password), 'PBKDF2', false, ['deriveKey']);
  const key = await crypto.subtle.deriveKey(
    { name:'PBKDF2', salt: salt, iterations: PBKDF2_ITER, hash:'SHA-256' },
    baseKey,
    { name:'AES-GCM', length:256 },
    false,
    ['encrypt','decrypt']
  );
  return key;
}

async function encryptNotes(notesArray, password){
  const salt = getRandomBytes(SALT_LEN);
  const iv = getRandomBytes(IV_LEN);
  const key = await deriveKeyFromPassword(password, salt);
  const enc = new TextEncoder();
  const plaintext = enc.encode(JSON.stringify(notesArray));
  const cipher = await crypto.subtle.encrypt({ name:'AES-GCM', iv: iv }, key, plaintext);
  const magic = new TextEncoder().encode(FILE_MAGIC);
  const out = new Uint8Array(magic.length + salt.length + iv.length + cipher.byteLength);
  let off=0;
  out.set(magic, off); off+=magic.length;
  out.set(salt, off); off+=salt.length;
  out.set(iv, off); off+=iv.length;
  out.set(new Uint8Array(cipher), off);
  return out.buffer;
}

async function decryptNotes(arrayBuffer, password){
  const data = new Uint8Array(arrayBuffer);
  const magicLen = FILE_MAGIC.length;
  const magic = new TextDecoder().decode(data.slice(0, magicLen));
  if(magic !== FILE_MAGIC) throw new Error('檔案格式錯誤');
  const salt = data.slice(magicLen, magicLen+SALT_LEN).buffer;
  const iv = data.slice(magicLen+SALT_LEN, magicLen+SALT_LEN+IV_LEN);
  const cipher = data.slice(magicLen+SALT_LEN+IV_LEN).buffer;
  const key = await deriveKeyFromPassword(password, salt);
  const plain = await crypto.subtle.decrypt({ name:'AES-GCM', iv: iv }, key, cipher);
  return JSON.parse(new TextDecoder().decode(plain));
}

/* save helper with fallback */
async function saveArrayBufferToDevice(buf, suggestedName='memoroa.dat'){
  if(window.showSaveFilePicker){
    const opts = { suggestedName, types:[{ description:'Memoroa backup', accept:{ 'application/octet-stream':['.dat'] }}] };
    const handle = await window.showSaveFilePicker(opts);
    const writable = await handle.createWritable();
    await writable.write(buf);
    await writable.close();
    return true;
  } else {
    const blob = new Blob([buf], { type:'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = suggestedName;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    return true;
  }
}

/* open helper with fallback */
async function openFileFromDevice(){
  if(window.showOpenFilePicker){
    const [handle] = await window.showOpenFilePicker({ types:[{ description:'Memoroa backup', accept:{ 'application/octet-stream':['.dat'] }}], multiple:false });
    const file = await handle.getFile();
    const ab = await file.arrayBuffer();
    return ab;
  } else {
    return await new Promise((resolve,reject)=>{
      const input = document.createElement('input');
      input.type='file';
      input.accept='.dat,application/octet-stream';
      input.onchange = async (e)=>{
        const f = e.target.files[0];
        if(!f) { reject(new Error('使用者取消')); return; }
        const ab = await f.arrayBuffer();
        resolve(ab);
      };
      input.click();
    });
  }
}

/* ---------- Modal 控制：等使用者在 modal 裡按確定（這保證後續 showSaveFilePicker 是 user gesture） ---------- */
function askPassword(title){
  return new Promise((resolve,reject)=>{
    pwTitle.textContent = title || '請輸入密碼';
    pwInput.value = '';
    pwModal.style.display = 'flex';
    pwInput.focus();

    function cleanup(){
      pwModal.style.display = 'none';
      pwOk.removeEventListener('click', onOk);
      pwCancel.removeEventListener('click', onCancel);
      pwInput.removeEventListener('keydown', onKey);
    }
    function onOk(){
      const v = pwInput.value;
      if(!v){ alert('密碼不可為空'); return; }
      cleanup();
      resolve(v);
    }
    function onCancel(){
      cleanup();
      reject(new Error('使用者取消'));
    }
    function onKey(e){
      if(e.key==='Enter'){ onOk(); }
      if(e.key==='Escape'){ onCancel(); }
    }
    pwOk.addEventListener('click', onOk);
    pwCancel.addEventListener('click', onCancel);
    pwInput.addEventListener('keydown', onKey);
  });
}

/* ---------- 備份流程 ---------- */
document.getElementById('backupBtn').addEventListener('click', async ()=>{
  try{
    const currentNotes = getNotesFromStorage();
    if(!currentNotes || currentNotes.length===0){
      alert('目前沒有筆記可備份。');
      return;
    }
    const password = await askPassword('備份：請輸入備份密碼（請記住）');
    const buf = await encryptNotes(currentNotes, password);
    await saveArrayBufferToDevice(buf, 'memoroa.dat');
    alert('備份成功（已下載或寫入裝置）。');
  }catch(err){
    if(err && err.message==='使用者取消') return;
    console.error(err);
    alert('備份失敗：' + (err && err.message ? err.message : err));
  }
});

/* ---------- 還原流程 ---------- */
document.getElementById('restoreBtn').addEventListener('click', async ()=>{
  try{
    const buf = await openFileFromDevice();
    const password = await askPassword('還原：請輸入備份檔案的密碼');
    const notesArr = await decryptNotes(buf, password);
    localStorage.setItem('notes', JSON.stringify(notesArr));
    notes = notesArr;
    renderSidebar();
    if(notes.length>0) selectNote(notes[0].id);
    alert('還原成功（已覆蓋本地筆記）。');
  }catch(err){
    if(err && err.message==='使用者取消') return;
    console.error(err);
    alert('還原失敗：' + (err && err.message ? err.message : err));
  }
});

/* optional: 不自動關閉 modal 的點擊（保守處理） */
pwModal.addEventListener('click', (e)=>{
  if(e.target===pwModal){
    // 保守：不自動關閉，避免誤觸
  }
});

/* PWA: 註冊 Service Worker（如果有） */
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./service-worker.js')
      .then(() => console.log('Service Worker registered'))
      .catch(err => console.log('SW error:', err));
  });
}
</script>
</body>
</html>
