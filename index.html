<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Memoroa</title>
  <link rel="manifest" href="./manifest.json">
  <style>
    /* ä½ çš„åŸæœ¬ CSS å®Œæ•´ä¿ç•™ï¼ˆä¸è®Šï¼‰ */
    :root {
      --bg-color: #f5f7fa;
      --sidebar-bg: #ffffff;
      --note-item-hover: #eef1f5;
      --note-item-active: #e0e9f0;
      --primary-color: #007bff;
      --btn-text-color: #ffffff;
      --border-color: #e0e6ed;
      --text-color: #333;
      --placeholder-color: #93a5b8;
      --shadow-light: 0 4px 6px rgba(0, 0, 0, 0.05);
      --delete-btn-color: #999;
    }

    body {
      font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
      display: flex;
      height: 100vh;
      margin: 0;
      background-color: var(--bg-color);
      color: var(--text-color);
      overflow: hidden;
    }

    #sidebar {
      width: 300px;
      background-color: var(--sidebar-bg);
      padding: 20px 0;
      border-right: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      box-shadow: var(--shadow-light);
      transition: width 0.3s ease;
    }

    #new-note-btn {
      type: button;
      background-color: var(--primary-color);
      color: var(--btn-text-color);
      border: none;
      padding: 12px 20px;
      margin: 0 20px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      transition: background-color 0.2s ease, transform 0.1s ease;
    }

    #new-note-btn:hover {
      background-color: #0056b3;
      transform: translateY(-1px);
    }

    #note-list {
      list-style: none;
      padding: 0;
      margin: 0;
      flex-grow: 1;
      overflow-y: auto;
    }

    .note-item {
      padding: 15px 20px;
      cursor: pointer;
      border-bottom: 1px solid var(--border-color);
      transition: background-color 0.2s ease;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .note-item:hover {
      background-color: var(--note-item-hover);
    }

    .note-item.active {
      background-color: var(--note-item-active);
      border-left: 4px solid var(--primary-color);
      padding-left: 16px;
    }

    .note-title {
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex-grow: 1;
    }

    .note-preview {
      font-size: 14px;
      color: var(--placeholder-color);
      margin-top: 5px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .delete-btn {
      background: none;
      border: none;
      color: var(--delete-btn-color);
      font-size: 18px;
      cursor: pointer;
      opacity: 0.5;
      transition: opacity 0.2s ease, color 0.2s ease;
      margin-left: 10px;
    }

    .delete-btn:hover {
      color: red;
      opacity: 1;
    }

    #main-content {
      flex-grow: 1;
      padding: 30px;
      display: flex;
      flex-direction: column;
      min-height: 0; /* å…è¨±å…§å±¤æ»¾å‹• */
    }

    #toolbar {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
      background-color: var(--sidebar-bg);
      padding: 10px;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      align-items: center;
    }

    .format-btn {
      background-color: var(--note-item-hover);
      border: 1px solid var(--border-color);
      padding: 8px 12px;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
      font-size: 16px;
    }

    .backup-btn {
      margin-left: auto;
      background-color: #2d9cdb;
      color: #fff;
      border: none;
      padding: 8px 10px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
    }

    .backup-btn:hover { filter: brightness(0.95); }

    #note-editor {
      width: 100%;
      flex-grow: 1;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 20px;
      font-size: 18px;
      line-height: 1.6;
      background-color: var(--sidebar-bg);
      box-shadow: var(--shadow-light);
      transition: all 0.2s ease;
      outline: none;
      overflow-y: auto;
      white-space: pre-wrap;
      word-wrap: break-word;
      min-height: 0;
    }

    #note-editor:focus {
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
    }

    #note-editor[contenteditable="true"]:empty::before {
      content: attr(data-placeholder);
      color: var(--placeholder-color);
    }

    #note-editor ul li { list-style-type: none; }
    #note-editor ul li::before {
      content: 'â£';
      color: var(--primary-color);
      display: inline-block;
      width: 1em;
      margin-left: -1em;
    }

    @media (max-width: 768px) {
      body { flex-direction: column; }
      #sidebar { width: 100%; height: 35vh; border-right: none; border-bottom: 1px solid var(--border-color); padding: 10px 0; }
      #new-note-btn { margin: 0 15px 15px; padding: 10px 15px; }
      #note-list { flex-grow: 1; overflow-y: auto; padding-bottom: 10px; }
      .note-item { padding: 12px 15px; }
      #main-content { flex-grow: 1; padding: 15px; }
      #note-editor { width: calc(100% - 2px); box-sizing: border-box; min-height: 150px; height: auto; }
    }
  </style>
</head>
<body>
  <div id="sidebar">
    <button id="new-note-btn" type="button">ï¼‹ æ–°å¢ç­†è¨˜</button>
    <ul id="note-list"></ul>
  </div>

  <div id="main-content">
    <div id="toolbar">
      <button class="format-btn" type="button" onclick="formatDoc('bold')"><b>ç²—é«”</b></button>
      <button class="format-btn" type="button" onclick="formatDoc('italic')"><i>æ–œé«”</i></button>
      <button class="format-btn" type="button" onclick="formatDoc('insertUnorderedList')">é …ç›®</button>
      <button class="format-btn" type="button" onclick="formatDoc('insertOrderedList')">æ•¸å­—</button>

      <!-- å‚™ä»½ / é‚„åŸæŒ‰éˆ• -->
      <button id="backupBtn" class="backup-btn" type="button">å‚™ä»½åˆ°è£ç½®</button>
      <button id="restoreBtn" class="backup-btn" type="button" style="background-color:#4caf50;margin-left:6px">å¾è£ç½®é‚„åŸ</button>
    </div>

    <div id="note-editor" contenteditable="true" data-placeholder="åœ¨æ­¤é–‹å§‹å¯«ç­†è¨˜..."></div>
  </div>

  <script>
    /* ä½ çš„åŸæœ¬ JS - é™¤äº†å‚™ä»½/å„²å­˜é‚£æ®µæœ‰èª¿æ•´é †åºï¼Œå…¶é¤˜ç¶­æŒåŸæ¨£ */

    const noteList = document.getElementById('note-list');
    const noteEditor = document.getElementById('note-editor');
    const newNoteBtn = document.getElementById('new-note-btn');
    const backupBtn = document.getElementById('backupBtn');
    const restoreBtn = document.getElementById('restoreBtn');

    let currentNoteId = null;
    let saveTimer;

    window.onload = loadNotes;
    newNoteBtn.onclick = newNote;
    noteEditor.oninput = () => {
      clearTimeout(saveTimer);
      saveTimer = setTimeout(saveNote, 500);
    };

    function formatDoc(command) {
      document.execCommand(command, false, null);
      noteEditor.focus();
    }

    function addNoteToSidebar(note, isActive = false) {
      const li = document.createElement('li');
      li.className = 'note-item';
      if (isActive) li.classList.add('active');
      li.setAttribute('data-id', note.id);

      const contentWrapper = document.createElement('div');
      const title = document.createElement('div');
      title.className = 'note-title';
      const preview = document.createElement('div');
      preview.className = 'note-preview';
      contentWrapper.appendChild(title);
      contentWrapper.appendChild(preview);

      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'delete-btn';
      deleteBtn.type = 'button';
      deleteBtn.textContent = 'Ã—';
      deleteBtn.onclick = (e) => {
        e.stopPropagation();
        deleteNote(note.id);
      };

      li.appendChild(contentWrapper);
      li.appendChild(deleteBtn);

      li.addEventListener('mousedown', (e) => {
        if (e.target.closest('.delete-btn')) return;
        selectNote(note.id);
      });

      updateNoteItemContent(li, note.content);
      noteList.prepend(li);
      return li;
    }

    function updateNoteItemContent(item, content) {
      const titleElement = item.querySelector('.note-title');
      const previewElement = item.querySelector('.note-preview');
      if (!titleElement || !previewElement) return;
      const plainTextWithNewlines = content
        .replace(/<br\s*\/?>/gi, "\n")
        .replace(/<\/div>|<\/p>/gi, "\n");
      const plainText = plainTextWithNewlines.replace(/<[^>]*>?/gm, '').trim();
      const lines = plainText.split('\n').filter(line => line.trim() !== '');
      titleElement.textContent = lines[0] ? lines[0].substring(0, 30) : "æ–°ç­†è¨˜";
      previewElement.textContent = lines[1] ? lines[1] : "ç„¡é è¦½";
    }

    function loadNotes() {
      noteList.innerHTML = '';
      const notes = getNotesFromStorage();
      notes.forEach(note => addNoteToSidebar(note));
      if (notes.length > 0) selectNote(notes[0].id);
      else newNote();
    }

    function saveNote() {
      const content = noteEditor.innerHTML;
      let notes = getNotesFromStorage();
      if (!content.trim() && currentNoteId) {
        deleteNote(currentNoteId);
        return;
      }
      if (currentNoteId) {
        const noteToUpdate = notes.find(note => note.id === currentNoteId);
        if (noteToUpdate && noteToUpdate.content !== content) {
          noteToUpdate.content = content;
          const item = document.querySelector(`.note-item[data-id="${currentNoteId}"]`);
          if (item) updateNoteItemContent(item, content);
        }
      } else if (content.trim()) {
        const newNote = { id: Date.now().toString(), content: content };
        notes.unshift(newNote);
        currentNoteId = newNote.id;
        document.querySelectorAll('.note-item.active').forEach(item => item.classList.remove('active'));
        addNoteToSidebar(newNote, true);
      }
      localStorage.setItem('notes', JSON.stringify(notes));
    }

    function selectNote(id) {
      const notes = getNotesFromStorage();
      const selectedNote = notes.find(note => note.id === id);
      if (selectedNote) {
        noteEditor.innerHTML = selectedNote.content;
        currentNoteId = id;
        document.querySelectorAll('.note-item').forEach(item => {
          item.classList.toggle('active', item.getAttribute('data-id') === id);
        });
        noteEditor.focus();
      }
    }

    function newNote() {
      noteEditor.innerHTML = '';
      currentNoteId = null;
      document.querySelectorAll('.note-item.active').forEach(item => item.classList.remove('active'));
      noteEditor.focus();
    }

    function deleteNote(id) {
      let notes = getNotesFromStorage();
      notes = notes.filter(note => note.id !== id);
      localStorage.setItem('notes', JSON.stringify(notes));
      const itemToRemove = document.querySelector(`.note-item[data-id="${id}"]`);
      if (itemToRemove) itemToRemove.remove();
      if (currentNoteId === id) {
        if (notes.length > 0) selectNote(notes[0].id);
        else newNote();
      }
    }

    function getNotesFromStorage() {
      try {
        const notesJSON = localStorage.getItem('notes');
        return notesJSON ? JSON.parse(notesJSON) : [];
      } catch (e) {
        console.error("ç„¡æ³•è§£æ localStorage ä¸­çš„ç­†è¨˜", e);
        return [];
      }
    }

    /* ========== åŠ å¯† / æª”æ¡ˆè™•ç† ========== */
    const FILE_MAGIC = 'MEMO';
    const SALT_LEN = 16;
    const IV_LEN = 12;
    const PBKDF2_ITER = 150_000;

    function getRandomBytes(len) {
      const b = new Uint8Array(len);
      crypto.getRandomValues(b);
      return b;
    }

    async function deriveKeyFromPassword(password, salt) {
      const enc = new TextEncoder();
      const passKey = await crypto.subtle.importKey(
        "raw", enc.encode(password), { name: "PBKDF2" }, false, ["deriveKey"]
      );
      const key = await crypto.subtle.deriveKey(
        { name: "PBKDF2", salt: salt, iterations: PBKDF2_ITER, hash: "SHA-256" },
        passKey,
        { name: "AES-GCM", length: 256 },
        true,
        ["encrypt", "decrypt"]
      );
      return key;
    }

    async function encryptNotesToUint8(notesArray, password) {
      const salt = getRandomBytes(SALT_LEN);
      const iv = getRandomBytes(IV_LEN);
      const key = await deriveKeyFromPassword(password, salt.buffer);
      const encoder = new TextEncoder();
      const plaintext = encoder.encode(JSON.stringify(notesArray));
      const cipher = await crypto.subtle.encrypt({ name: "AES-GCM", iv: iv }, key, plaintext);
      const magicBuf = new TextEncoder().encode(FILE_MAGIC);
      const saltBuf = salt;
      const ivBuf = iv;
      const cipherBuf = new Uint8Array(cipher);
      const out = new Uint8Array(magicBuf.length + saltBuf.length + ivBuf.length + cipherBuf.length);
      let offset = 0;
      out.set(magicBuf, offset); offset += magicBuf.length;
      out.set(saltBuf, offset); offset += saltBuf.length;
      out.set(ivBuf, offset); offset += ivBuf.length;
      out.set(cipherBuf, offset);
      return out.buffer;
    }

    async function decryptUint8ToNotes(arrayBuffer, password) {
      const data = new Uint8Array(arrayBuffer);
      const magicLen = FILE_MAGIC.length;
      const magic = new TextDecoder().decode(data.slice(0, magicLen));
      if (magic !== FILE_MAGIC) throw new Error('æª”æ¡ˆæ ¼å¼ä¸æ­£ç¢º');
      const salt = data.slice(magicLen, magicLen + SALT_LEN).buffer;
      const iv = data.slice(magicLen + SALT_LEN, magicLen + SALT_LEN + IV_LEN);
      const cipher = data.slice(magicLen + SALT_LEN + IV_LEN).buffer;
      const key = await deriveKeyFromPassword(password, salt);
      const plainBuf = await crypto.subtle.decrypt({ name: "AES-GCM", iv: iv }, key, cipher);
      const decoded = new TextDecoder().decode(plainBuf);
      return JSON.parse(decoded);
    }

    /* ---------- æ–°ï¼šåœ¨ user gesture æœŸé–“å…ˆ open save handleï¼ˆè‹¥å¯ç”¨ï¼‰ï¼Œå†åšåŠ å¯† ---------- */
    async function saveWithPickerFlow(notesArray, password) {
      // å…ˆå–å¾— handleï¼ˆå¿…é ˆåœ¨ user gesture æœŸé–“å‘¼å«ï¼‰
      const opts = {
        types: [{
          description: 'Memoroa backup',
          accept: { 'application/octet-stream': ['.dat'] }
        }],
        suggestedName: 'memoroa.dat'
      };
      const handle = await window.showSaveFilePicker(opts);
      // æ¥è‘—åšåŠ å¯†ï¼ˆasync heavyï¼‰ï¼Œä¸¦å¯«å…¥ handle
      const arrayBuf = await encryptNotesToUint8(notesArray, password);
      const writable = await handle.createWritable();
      await writable.write(arrayBuf);
      await writable.close();
      return true;
    }

    // fallback: åšå®ŒåŠ å¯†å†è§¸ç™¼ä¸‹è¼‰ï¼ˆåœ¨æŸäº›ç€è¦½å™¨æœƒå…è¨±ï¼‰
    async function saveByDownloadFlow(notesArray, password, suggestedName='memoroa.dat') {
      const arrayBuf = await encryptNotesToUint8(notesArray, password);
      const blob = new Blob([arrayBuf], { type: 'application/octet-stream' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = suggestedName;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      return true;
    }

    // open file helper (keeps direct call in user gesture)
    async function openFileFromDevice() {
      if (window.showOpenFilePicker) {
        const [handle] = await window.showOpenFilePicker({
          types: [{
            description: 'Memoroa backup',
            accept: { 'application/octet-stream': ['.dat'] }
          }],
          multiple: false
        });
        const file = await handle.getFile();
        const arrayBuffer = await file.arrayBuffer();
        return { arrayBuffer, handle, name: file.name };
      } else {
        return await new Promise((resolve, reject) => {
          const input = document.createElement('input');
          input.type = 'file';
          input.accept = '.dat,application/octet-stream';
          input.onchange = async (e) => {
            const f = e.target.files[0];
            if (!f) { reject(new Error('ä½¿ç”¨è€…å–æ¶ˆ')); return; }
            const arrayBuffer = await f.arrayBuffer();
            resolve({ arrayBuffer, handle: null, name: f.name });
          };
          input.click();
        });
      }
    }

    // prompt å¯†ç¢¼ï¼ˆåŒæ­¥ prompt ä¿ç•™ï¼‰
    function promptPassword(promptText = 'è«‹è¼¸å…¥å‚™ä»½å¯†ç¢¼') {
    return new Promise((resolve, reject) => {
        const overlay = document.getElementById('password-overlay');
        const title = document.getElementById('overlay-title');
        const passwordInput = document.getElementById('overlay-password');
        const confirmBtn = document.getElementById('overlay-confirm');
        const cancelBtn = document.getElementById('overlay-cancel');

        title.textContent = promptText;
        passwordInput.value = ''; // æ¸…ç©ºæ¬„ä½
        overlay.style.display = 'flex'; // é¡¯ç¤ºè¦–çª—

        // ç¶å®šç¢ºèªäº‹ä»¶
        confirmBtn.onclick = () => {
            const p = passwordInput.value;
            if (p.length < 4) {
                // é€™è£¡å¯ä»¥æ›æˆæ›´å‹å–„çš„éŒ¯èª¤æç¤ºï¼Œä¾‹å¦‚åœ¨è¦–çª—å…§é¡¯ç¤ºè­¦å‘Š
                alert('å»ºè­°ä½¿ç”¨è¼ƒé•·å¯†ç¢¼ (è‡³å°‘ 4 å€‹å­—)ï¼Œè«‹é‡æ–°è¼¸å…¥æˆ–ç¢ºèª'); 
                return;
            }
            overlay.style.display = 'none'; // éš±è—è¦–çª—
            resolve(p); // å‚³å›å¯†ç¢¼
        };

        // ç¶å®šå–æ¶ˆäº‹ä»¶
        cancelBtn.onclick = () => {
            overlay.style.display = 'none'; // éš±è—è¦–çª—
            reject(new Error('ä½¿ç”¨è€…å–æ¶ˆ'));
        };
        
        passwordInput.focus();
    });
}

    /* ---------- å‚™ä»½æŒ‰éˆ•ï¼šå…ˆåœ¨ gesture å…§å˜—è©¦ open handleï¼ˆè‹¥æ”¯æ´ï¼‰ï¼Œå†åšåŠ å¯†èˆ‡å¯«å…¥ ---------- */
    /* ---------- ä¿®æ­£å¾Œçš„å‚™ä»½æŒ‰éˆ•ï¼šå…ˆå•å¯†ç¢¼ï¼Œå†å‚™ä»½ (ä¸¦åŠ ä¸Š await) ---------- */
/* ---------- ä¿®æ­£å¾Œçš„å‚™ä»½æŒ‰éˆ•ï¼šå…ˆå•å¯†ç¢¼ï¼Œå†å‚™ä»½ (ä¸¦åŠ ä¸Š await) ---------- */
backupBtn.addEventListener('click', async () => {
    try {
        const notes = getNotesFromStorage();
        if (!notes || notes.length === 0) {
            alert('ç›®å‰æ²’æœ‰ä»»ä½•ç­†è¨˜å¯å‚™ä»½ã€‚');
            return;
        }

        // ğŸŒŸ ä¿®æ­£é» A: å‚™ä»½å‰è©¢å•å¯†ç¢¼ï¼Œä¸¦ä½¿ç”¨ await ç­‰å¾…è¼¸å…¥å®Œæˆ
        const password = await promptPassword('å‚™ä»½ï¼šè«‹è¼¸å…¥å‚™ä»½å¯†ç¢¼ï¼ˆå°‡ç”¨ä¾†åŠ å¯†ï¼‰');

        if (window.showSaveFilePicker) {
            // é‡è¦ï¼šcall showSaveFilePicker BEFORE heavy async work (keeps gesture)
            try {
                await saveWithPickerFlow(notes, password);
                alert('å·²å°‡å‚™ä»½æª”æ¡ˆå¯«å…¥è£ç½®ï¼ˆmemoroa.datï¼‰ã€‚è«‹å¦¥å–„ä¿å­˜å¯†ç¢¼ä»¥ä¾¿é‚„åŸã€‚');
                return;
            } catch (e) {
                // è‹¥ä½¿ç”¨è€…åœ¨æª”æ¡ˆå°è©±æ¡†å–æ¶ˆæˆ–å…¶ä»–éŒ¯èª¤ï¼Œå›é€€åˆ°ä¸‹è¼‰æµç¨‹æˆ–é¡¯ç¤ºéŒ¯èª¤
                if (e.name === 'AbortError' || e.message === 'The user aborted a request.') {
                    console.warn('ä½¿ç”¨è€…å–æ¶ˆæª”æ¡ˆé¸æ“‡');
                    return;
                }
                console.warn('saveWithPickerFlow ç™¼ç”ŸéŒ¯èª¤ï¼Œå˜—è©¦ fallbackï¼š', e);
                // è¿½çºŒåˆ° fallback ä¸‹è¼‰æµç¨‹
            }
        }

        // fallback (ä¸‹è¼‰)
        await saveByDownloadFlow(notes, password, 'memoroa.dat');
        alert('å·²å°‡å‚™ä»½æª”æ¡ˆä¸‹è¼‰åˆ°è£ç½®ï¼ˆmemoroa.datï¼‰ã€‚è«‹å¦¥å–„ä¿å­˜å¯†ç¢¼ä»¥ä¾¿é‚„åŸã€‚');
    } catch (e) {
        if (e.message === 'ä½¿ç”¨è€…å–æ¶ˆ') return;
        console.error(e);
        alert('å‚™ä»½å¤±æ•—ï¼š' + (e.message || e));
    }
});

    /* ---------- é‚„åŸæµç¨‹ ---------- */
/* ---------- ä¿®æ­£å¾Œçš„é‚„åŸæµç¨‹ (åŠ ä¸Š await) ---------- */
/* ---------- ä¿®æ­£å¾Œçš„é‚„åŸæµç¨‹ (æ‰€æœ‰ promptPassword éƒ½åŠ ä¸Š await) ---------- */
restoreBtn.addEventListener('click', async () => {
    try {
        let arrayBuffer;
        let password;
        
        // --- è™•ç† showOpenFilePicker æ”¯æ´çš„ç€è¦½å™¨ (Chromium/æ–°ç‰ˆ) ---
        if (window.showOpenFilePicker) {
            // æ­¥é©Ÿ 1: åœ¨ User Gesture å…§é–‹å•Ÿæª”æ¡ˆé¸æ“‡å™¨
            const [handle] = await window.showOpenFilePicker({
                types: [{
                    description: 'Memoroa backup',
                    accept: { 'application/octet-stream': ['.dat'] }
                }],
                multiple: false
            });
            const file = await handle.getFile();
            arrayBuffer = await file.arrayBuffer();

            // ğŸŒŸ ä¿®æ­£é» B: æª”æ¡ˆé¸å¥½å¾Œï¼Œä½¿ç”¨ await è©¢å•å¯†ç¢¼
            password = await promptPassword('é‚„åŸï¼šè«‹è¼¸å…¥å‚™ä»½æª”æ¡ˆçš„å¯†ç¢¼'); 

        } 
        // --- è™•ç†å‚³çµ± <input type="file"> çš„ç€è¦½å™¨ (èˆŠç‰ˆ Android æˆ–å…¶ä»–) ---
        else {
            // å¿…é ˆä½¿ç”¨ Promise ä¾†åŒ…è£ï¼Œè®“æµç¨‹åœç­‰
            const { arrayBuffer: buf, password: pw } = await new Promise((resolve, reject) => {
                // 1. å‹•æ…‹å»ºç«‹ input å…ƒç´ 
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.dat,application/octet-stream';

                input.onchange = async (e) => {
                    const f = e.target.files[0];
                    if (!f) { reject(new Error('ä½¿ç”¨è€…å–æ¶ˆ')); return; }
                    
                    // 2. æª”æ¡ˆé¸å¥½ (onchange è§¸ç™¼) å¾Œï¼Œä½¿ç”¨ await è©¢å•å¯†ç¢¼
                    try {
                        // ğŸŒŸ ä¿®æ­£é» C: å¿…é ˆåœ¨ promptPassword å‰åŠ ä¸Š await
                        const password = await promptPassword('é‚„åŸï¼šè«‹è¼¸å…¥å‚™ä»½æª”æ¡ˆçš„å¯†ç¢¼'); 
                        const arrayBuffer = await f.arrayBuffer();
                        resolve({ arrayBuffer, password });
                    } catch(err) {
                        reject(err);
                    }
                };

                input.click();
            });
            
            arrayBuffer = buf;
            password = pw;
        }

        // --- å…±åŒçš„é‚„åŸé‚è¼¯ ---
        // åªæœ‰åœ¨æ­£ç¢ºå–å¾—å¯†ç¢¼å¾Œï¼Œæ‰æœƒèµ°åˆ°é€™è£¡ä¸¦åŸ·è¡Œè§£å¯†
        const notes = await decryptUint8ToNotes(arrayBuffer, password);
        localStorage.setItem('notes', JSON.stringify(notes));
        loadNotes();
        alert('é‚„åŸæˆåŠŸï¼ˆå·²è¦†è“‹ç›®å‰ç­†è¨˜è³‡æ–™ï¼‰ã€‚');
    } catch (e) {
        if (e.message === 'ä½¿ç”¨è€…å–æ¶ˆ' || e.name === 'AbortError') return;
        
        // æª¢æŸ¥æ˜¯å¦ç‚ºå¯†ç¢¼éŒ¯èª¤
        if (e.name === 'OperationError' && (e.message.includes('The operation failed for an operation-specific reason') || e.message.includes('Decryption failed'))) {
            alert('é‚„åŸå¤±æ•—ï¼šå¯†ç¢¼éŒ¯èª¤ï¼Œè«‹é‡æ–°è¼¸å…¥ã€‚');
        } else {
            alert('é‚„åŸå¤±æ•—ï¼š' + (e.message || e));
        }
        console.error(e);
    }
});

    // PWA - è¨»å†Š Service Workerï¼ˆä¿ç•™ä½ åŸæœ¬çš„ï¼‰
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js')
          .then(registration => {
            console.log('Service Worker registered: ', registration);
          })
          .catch(registrationError => {
            console.log('Service Worker registration failed: ', registrationError);
          });
      });
    }

  </script>
  <div id="password-overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.6); z-index:1000; justify-content:center; align-items:center;">
    <div style="background:white; padding:30px; border-radius:10px; box-shadow:0 5px 15px rgba(0,0,0,0.3); max-width: 300px; width: 90%;">
        <h3 id="overlay-title" style="margin-top:0;">è«‹è¼¸å…¥å¯†ç¢¼</h3>
        <input type="password" id="overlay-password" placeholder="å¯†ç¢¼" style="width:100%; padding:10px; margin-bottom:15px; border:1px solid #ccc; border-radius:5px;">
        <button id="overlay-confirm" style="background-color:#007bff; color:white; border:none; padding:10px 15px; border-radius:5px; cursor:pointer; margin-right: 10px;">ç¢ºèª</button>
        <button id="overlay-cancel" style="background-color:#ccc; color:#333; border:none; padding:10px 15px; border-radius:5px; cursor:pointer;">å–æ¶ˆ</button>
    </div>
</div>
</body>
</html>




