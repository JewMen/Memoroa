<!DOCTYPE html> <html lang="zh-TW"> <head> <meta charset="UTF-8" /> <meta name="viewport" content="width=device-width, initial-scale=1.0"/> <title>Memoroa</title> <link rel="manifest" href="./manifest.json"> <style> :root { --bg-color: #f5f7fa; --sidebar-bg: #ffffff; --note-item-hover: #eef1f5; --note-item-active: #e0e9f0; --primary-color: #007bff; --btn-text-color: #ffffff; --border-color: #e0e6ed; --text-color: #333; --placeholder-color: #93a5b8; --shadow-light: 0 4px 6px rgba(0, 0, 0, 0.05); --delete-btn-color: #999; } body { font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif; display: flex; height: 100vh; margin: 0; background-color: var(--bg-color); color: var(--text-color); overflow: hidden; } #sidebar { width: 300px; background-color: var(--sidebar-bg); padding: 20px 0; border-right: 1px solid var(--border-color); display: flex; flex-direction: column; box-shadow: var(--shadow-light); transition: width 0.3s ease; } #new-note-btn { type: button; background-color: var(--primary-color); color: var(--btn-text-color); border: none; padding: 12px 20px; margin: 0 20px 20px; border-radius: 8px; cursor: pointer; font-weight: bold; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); transition: background-color 0.2s ease, transform 0.1s ease; } #new-note-btn:hover { background-color: #0056b3; transform: translateY(-1px); } #note-list { list-style: none; padding: 0; margin: 0; flex-grow: 1; overflow-y: auto; } .note-item { padding: 15px 20px; cursor: pointer; border-bottom: 1px solid var(--border-color); transition: background-color 0.2s ease; display: flex; justify-content: space-between; align-items: center; } .note-item:hover { background-color: var(--note-item-hover); } .note-item.active { background-color: var(--note-item-active); border-left: 4px solid var(--primary-color); padding-left: 16px; } .note-title { font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex-grow: 1; } .note-preview { font-size: 14px; color: var(--placeholder-color); margin-top: 5px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; } .delete-btn { background: none; border: none; color: var(--delete-btn-color); font-size: 18px; cursor: pointer; opacity: 0.5; transition: opacity 0.2s ease, color 0.2s ease; margin-left: 10px; } .delete-btn:hover { color: red; opacity: 1; } #main-content { flex-grow: 1; padding: 30px; display: flex; flex-direction: column; min-height: 0; /* 允許內層滾動 */ } #toolbar { display: flex; gap: 8px; margin-bottom: 10px; background-color: var(--sidebar-bg); padding: 10px; border-radius: 8px; border: 1px solid var(--border-color); align-items: center; } .format-btn { background-color: var(--note-item-hover); border: 1px solid var(--border-color); padding: 8px 12px; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 16px; } .backup-btn { margin-left: auto; background-color: #2d9cdb; color: #fff; border: none; padding: 8px 10px; border-radius: 6px; cursor: pointer; font-size: 14px; } .backup-btn:hover { filter: brightness(0.95); } #note-editor { width: 100%; flex-grow: 1; border: 1px solid var(--border-color); border-radius: 8px; padding: 20px; font-size: 18px; line-height: 1.6; background-color: var(--sidebar-bg); box-shadow: var(--shadow-light); transition: all 0.2s ease; outline: none; overflow-y: auto; white-space: pre-wrap; word-wrap: break-word; min-height: 0; } #note-editor:focus { border-color: var(--primary-color); box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25); } #note-editor[contenteditable="true"]:empty::before { content: attr(data-placeholder); color: var(--placeholder-color); } #note-editor ul li { list-style-type: none; } #note-editor ul li::before { content: '➣'; color: var(--primary-color); display: inline-block; width: 1em; margin-left: -1em; } @media (max-width: 768px) { body { flex-direction: column; } #sidebar { width: 100%; height: 35vh; border-right: none; border-bottom: 1px solid var(--border-color); padding: 10px 0; } #new-note-btn { margin: 0 15px 15px; padding: 10px 15px; } #note-list { flex-grow: 1; overflow-y: auto; padding-bottom: 10px; } .note-item { padding: 12px 15px; } #main-content { flex-grow: 1; padding: 15px; } #note-editor { width: calc(100% - 2px); box-sizing: border-box; min-height: 150px; height: auto; } } </style> </head> <body> <div id="sidebar"> <button id="new-note-btn" type="button">＋ 新增筆記</button> <ul id="note-list"></ul> </div> <div id="main-content"> <div id="toolbar"> <button class="format-btn" type="button" onclick="formatDoc('bold')"><b>粗體</b></button> <button class="format-btn" type="button" onclick="formatDoc('italic')"><i>斜體</i></button> <button class="format-btn" type="button" onclick="formatDoc('insertUnorderedList')">項目</button> <button class="format-btn" type="button" onclick="formatDoc('insertOrderedList')">數字</button> <!-- 備份 / 還原按鈕 --> <button id="backupBtn" class="backup-btn" type="button">備份到裝置</button> <button id="restoreBtn" class="backup-btn" type="button" style="background-color:#4caf50;margin-left:6px">從裝置還原</button> </div> <div id="note-editor" contenteditable="true" data-placeholder="在此開始寫筆記..."></div> </div> <script> /* =========================== 原本筆記 App 的核心程式（略作排版） 我保留並未變更功能行為（只有整合備份/還原功能） 並修正 select 與 querySelector 的 bug ============================ */ const noteList = document.getElementById('note-list'); const noteEditor = document.getElementById('note-editor'); const newNoteBtn = document.getElementById('new-note-btn'); const backupBtn = document.getElementById('backupBtn'); const restoreBtn = document.getElementById('restoreBtn'); let currentNoteId = null; let saveTimer; window.onload = loadNotes; newNoteBtn.onclick = newNote; noteEditor.oninput = () => { clearTimeout(saveTimer); saveTimer = setTimeout(saveNote, 500); }; function formatDoc(command) { document.execCommand(command, false, null); noteEditor.focus(); } function addNoteToSidebar(note, isActive = false) { const li = document.createElement('li'); li.className = 'note-item'; if (isActive) li.classList.add('active'); li.setAttribute('data-id', note.id); const contentWrapper = document.createElement('div'); const title = document.createElement('div'); title.className = 'note-title'; const preview = document.createElement('div'); preview.className = 'note-preview'; contentWrapper.appendChild(title); contentWrapper.appendChild(preview); const deleteBtn = document.createElement('button'); deleteBtn.className = 'delete-btn'; deleteBtn.type = 'button'; deleteBtn.textContent = '×'; deleteBtn.onclick = (e) => { e.stopPropagation(); deleteNote(note.id); }; li.appendChild(contentWrapper); li.appendChild(deleteBtn); // 使用 mousedown 而不是 click，避免 focus/selection 與 contentEditable 衝突 li.addEventListener('mousedown', (e) => { // 如果點擊到刪除按鈕，跳過選取 if (e.target.closest('.delete-btn')) return; selectNote(note.id); }); updateNoteItemContent(li, note.content); noteList.prepend(li); return li; } function updateNoteItemContent(item, content) { const titleElement = item.querySelector('.note-title'); const previewElement = item.querySelector('.note-preview'); if (!titleElement || !previewElement) return; const plainTextWithNewlines = content .replace(/<br\s*\/?>/gi, "\n") .replace(/<\/div>|<\/p>/gi, "\n"); const plainText = plainTextWithNewlines.replace(/<[^>]*>?/gm, '').trim(); const lines = plainText.split('\n').filter(line => line.trim() !== ''); titleElement.textContent = lines[0] ? lines[0].substring(0, 30) : "新筆記"; previewElement.textContent = lines[1] ? lines[1] : "無預覽"; } function loadNotes() { noteList.innerHTML = ''; const notes = getNotesFromStorage(); notes.forEach(note => addNoteToSidebar(note)); if (notes.length > 0) selectNote(notes[0].id); else newNote(); } function saveNote() { const content = noteEditor.innerHTML; let notes = getNotesFromStorage(); if (!content.trim() && currentNoteId) { deleteNote(currentNoteId); return; } if (currentNoteId) { const noteToUpdate = notes.find(note => note.id === currentNoteId); if (noteToUpdate && noteToUpdate.content !== content) { noteToUpdate.content = content; // 修正：selector 必須是字串（使用 template literal） const item = document.querySelector(.note-item[data-id="${currentNoteId}"]); if (item) updateNoteItemContent(item, content); } } else if (content.trim()) { const newNote = { id: Date.now().toString(), content: content }; notes.unshift(newNote); currentNoteId = newNote.id; document.querySelectorAll('.note-item.active').forEach(item => item.classList.remove('active')); addNoteToSidebar(newNote, true); } localStorage.setItem('notes', JSON.stringify(notes)); } function selectNote(id) { const notes = getNotesFromStorage(); const selectedNote = notes.find(note => note.id === id); if (selectedNote) { noteEditor.innerHTML = selectedNote.content; currentNoteId = id; document.querySelectorAll('.note-item').forEach(item => { item.classList.toggle('active', item.getAttribute('data-id') === id); }); noteEditor.focus(); } } function newNote() { noteEditor.innerHTML = ''; currentNoteId = null; document.querySelectorAll('.note-item.active').forEach(item => item.classList.remove('active')); noteEditor.focus(); } function deleteNote(id) { let notes = getNotesFromStorage(); notes = notes.filter(note => note.id !== id); localStorage.setItem('notes', JSON.stringify(notes)); // 修正：selector 必須是字串（使用 template literal） const itemToRemove = document.querySelector(.note-item[data-id="${id}"]); if (itemToRemove) itemToRemove.remove(); if (currentNoteId === id) { if (notes.length > 0) selectNote(notes[0].id); else newNote(); } } function getNotesFromStorage() { try { const notesJSON = localStorage.getItem('notes'); return notesJSON ? JSON.parse(notesJSON) : []; } catch (e) { console.error("無法解析 localStorage 中的筆記", e); return []; } } /* =========================== 以下為 File System + AES 加密備份/還原程式 - 檔名：memoroa.dat - 格式： "MEMO" (4 bytes) + salt(16) + iv(12) + ciphertext - 密鑰由使用者輸入密碼透過 PBKDF2 派生（避免把 key 存在瀏覽器） ============================ */ const FILE_MAGIC = 'MEMO'; // 4 bytes const SALT_LEN = 16; const IV_LEN = 12; const PBKDF2_ITER = 150_000; // helper: convert between hex/base64/etc function bufToHex(buffer) { return Array.from(new Uint8Array(buffer)).map(b => b.toString(16).padStart(2,'0')).join(''); } function hexToBuf(hex) { const bytes = new Uint8Array(hex.length/2); for (let i=0;i<bytes.length;i++) bytes[i]=parseInt(hex.substr(i*2,2),16); return bytes.buffer; } async function deriveKeyFromPassword(password, salt) { const enc = new TextEncoder(); const passKey = await crypto.subtle.importKey( "raw", enc.encode(password), { name: "PBKDF2" }, false, ["deriveKey"] ); const key = await crypto.subtle.deriveKey( { name: "PBKDF2", salt: salt, iterations: PBKDF2_ITER, hash: "SHA-256" }, passKey, { name: "AES-GCM", length: 256 }, true, ["encrypt","decrypt"] ); return key; } function getRandomBytes(len) { const b = new Uint8Array(len); crypto.getRandomValues(b); return b; } async function encryptNotesToUint8(notesArray, password) { const salt = getRandomBytes(SALT_LEN); const iv = getRandomBytes(IV_LEN); const key = await deriveKeyFromPassword(password, salt.buffer); const encoder = new TextEncoder(); const plaintext = encoder.encode(JSON.stringify(notesArray)); const cipher = await crypto.subtle.encrypt({ name: "AES-GCM", iv: iv }, key, plaintext); // assemble: magic + salt + iv + ciphertext const magicBuf = new TextEncoder().encode(FILE_MAGIC); const saltBuf = salt; const ivBuf = iv; const cipherBuf = new Uint8Array(cipher); const out = new Uint8Array(magicBuf.length + saltBuf.length + ivBuf.length + cipherBuf.length); let offset = 0; out.set(magicBuf, offset); offset += magicBuf.length; out.set(saltBuf, offset); offset += saltBuf.length; out.set(ivBuf, offset); offset += ivBuf.length; out.set(cipherBuf, offset); return out.buffer; } async function decryptUint8ToNotes(arrayBuffer, password) { const data = new Uint8Array(arrayBuffer); const magicLen = FILE_MAGIC.length; const magic = new TextDecoder().decode(data.slice(0, magicLen)); if (magic !== FILE_MAGIC) throw new Error('檔案格式不正確'); const salt = data.slice(magicLen, magicLen + SALT_LEN).buffer; const iv = data.slice(magicLen + SALT_LEN, magicLen + SALT_LEN + IV_LEN); const cipher = data.slice(magicLen + SALT_LEN + IV_LEN).buffer; const key = await deriveKeyFromPassword(password, salt); const plainBuf = await crypto.subtle.decrypt({ name: "AES-GCM", iv: iv }, key, cipher); const decoded = new TextDecoder().decode(plainBuf); return JSON.parse(decoded); } // File writing using File System Access API (save dialog) async function saveFileToDevice(arrayBuffer, suggestedName = 'memoroa.dat') { // Fallback: if showSaveFilePicker isn't available, trigger download if (!window.showSaveFilePicker) { // create blob and download const blob = new Blob([arrayBuffer], { type: 'application/octet-stream' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = suggestedName; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); return null; } const opts = { types: [{ description: 'Memoroa backup', accept: { 'application/octet-stream': ['.dat'] } }], suggestedName }; const handle = await window.showSaveFilePicker(opts); const writable = await handle.createWritable(); await writable.write(arrayBuffer); await writable.close(); return handle; } // File reading using file picker (with fallback to input) async function openFileFromDevice() { if (window.showOpenFilePicker) { const [handle] = await window.showOpenFilePicker({ types: [{ description: 'Memoroa backup', accept: { 'application/octet-stream': ['.dat'] } }], multiple: false }); const file = await handle.getFile(); const arrayBuffer = await file.arrayBuffer(); return { arrayBuffer, handle, name: file.name }; } else { // fallback: create hidden file input return await new Promise((resolve, reject) => { const input = document.createElement('input'); input.type = 'file'; input.accept = '.dat,application/octet-stream'; input.onchange = async (e) => { const f = e.target.files[0]; if (!f) { reject(new Error('使用者取消')); return; } const arrayBuffer = await f.arrayBuffer(); resolve({ arrayBuffer, handle: null, name: f.name }); }; input.click(); }); } } // UI: prompt user for password (simple) function promptPassword(promptText = '請輸入備份密碼（會用來加密/解密）') { let p = prompt(promptText + '\n(請記住此密碼，忘記將無法還原檔案)'); if (p === null) throw new Error('使用者取消'); if (p.length < 4) { const ok = confirm('建議使用較長密碼 (至少 6 個字)，是否繼續？'); if (!ok) throw new Error('密碼太短'); } return p; } // 主流程：備份 backupBtn.addEventListener('click', async () => { try { const notes = getNotesFromStorage(); if (!notes || notes.length === 0) { alert('目前沒有任何筆記可備份。'); return; } const password = promptPassword('備份：請輸入備份密碼（將用來加密）'); const arrayBuf = await encryptNotesToUint8(notes, password); await saveFileToDevice(arrayBuf, 'memoroa.dat'); alert('已將備份檔案寫入裝置（memoroa.dat）。請妥善保存密碼以便還原。'); } catch (e) { if (e.message === '使用者取消') return; console.error(e); alert('備份失敗：' + (e.message || e)); } }); // 主流程：還原 restoreBtn.addEventListener('click', async () => { try { const { arrayBuffer, name } = await openFileFromDevice(); const password = promptPassword('還原：請輸入備份檔案的密碼'); const notes = await decryptUint8ToNotes(arrayBuffer, password); // overwrite localStorage (你也可以改成合併) localStorage.setItem('notes', JSON.stringify(notes)); loadNotes(); alert('還原成功（已覆蓋目前筆記資料）。'); } catch (e) { if (e.message === '使用者取消') return; console.error(e); alert('還原失敗：' + (e.message || e)); } }); // PWA - 註冊 Service Worker（保留你原本的） if ('serviceWorker' in navigator) { window.addEventListener('load', () => { navigator.serviceWorker.register('./service-worker.js') .then(registration => { console.log('Service Worker registered: ', registration); }) .catch(registrationError => { console.log('Service Worker registration failed: ', registrationError); }); }); } </script> </body> </html>
